<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI å§¿åŠ¿çŸ«æ­£ç³»ç»Ÿ</title>
    <!-- å¼•å…¥ Tailwind CSS ç”¨äºå¿«é€Ÿç¾åŒ–ç•Œé¢ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ TensorFlow.js æ ¸å¿ƒåº“å’Œ WebGL åç«¯ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.20.0/dist/tf-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.20.0/dist/tf-backend-webgl.min.js"></script>
    <!-- FIX: æ·»åŠ ç¼ºå¤±çš„ tfjs-converter åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter@4.20.0/dist/tf-converter.min.js"></script>
    <!-- å¼•å…¥å§¿åŠ¿æ£€æµ‹æ¨¡å‹ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>

    <style>
        /* è‡ªå®šä¹‰æ ·å¼ï¼Œè®©æ‘„åƒå¤´å’Œç”»å¸ƒå®Œç¾é‡å  */
        #video-container {
            position: relative;
            width: 640px;
            height: 480px;
        }
        #video, #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
        }
        /* ç¿»è½¬è§†é¢‘ä»¥å®ç°é•œåƒæ•ˆæœï¼Œæ›´ç¬¦åˆç›´è§‰ */
        #video {
            transform: scaleX(-1);
        }
        /* å¼¹çª—æ ·å¼ */
        #alert-modal {
            transition: opacity 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen font-sans p-4">

    <div class="w-full max-w-4xl bg-white rounded-lg shadow-xl p-6">
        <h1 class="text-3xl font-bold text-center text-slate-800 mb-2">AI å§¿åŠ¿çŸ«æ­£ç³»ç»Ÿ</h1>
        <p class="text-center text-slate-500 mb-4">è¯·ä¿æŒåå§¿ç«¯æ­£ï¼Œç³»ç»Ÿä¼šå®æ—¶ç›‘æµ‹æ‚¨çš„å§¿åŠ¿å¹¶åœ¨éœ€è¦æ—¶æé†’æ‚¨ã€‚</p>

        <!-- ä¸»ä½“å†…å®¹åŒºåŸŸ -->
        <div class="flex flex-col md:flex-row gap-6">
            
            <!-- è§†é¢‘å’Œç”»å¸ƒåŒºåŸŸ -->
            <div id="video-container" class="mx-auto bg-slate-200 rounded-lg shadow-inner">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="output-canvas"></canvas>
                <div id="loading-spinner" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-lg">
                     <p class="text-white text-lg">æ­£åœ¨åŠ è½½æ¨¡å‹å¹¶å¯åŠ¨æ‘„åƒå¤´...</p>
                </div>
            </div>

            <!-- çŠ¶æ€å’Œä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ -->
            <div class="flex-1 bg-slate-50 p-4 rounded-lg flex flex-col justify-between">
                <div>
                    <h2 class="text-xl font-semibold text-slate-700 border-b pb-2 mb-3">å½“å‰å§¿åŠ¿çŠ¶æ€</h2>
                    <div id="status-card" class="p-4 rounded-lg text-center transition-all duration-300">
                        <p id="status-text" class="text-2xl font-bold"></p>
                    </div>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-slate-700 mt-4 mb-2">å§¿åŠ¿çº æ­£å»ºè®®</h3>
                    <p id="suggestion-text" class="text-slate-600 h-16"></p>
                </div>
                 <div>
                    <h3 class="text-lg font-semibold text-slate-700 mt-4 mb-2">ä¸è‰¯å§¿åŠ¿æŒç»­æ—¶é—´</h3>
                    <p id="duration-text" class="text-slate-600 text-lg font-mono">0.00 ç§’</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- å¼¹çª—æé†’ -->
    <div id="alert-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 opacity-0 pointer-events-none z-50">
        <div class="bg-white rounded-xl shadow-2xl p-8 text-center max-w-sm transform scale-95 transition-transform duration-300">
            <div id="alert-icon" class="text-6xl mb-4"></div>
            <h2 id="alert-title" class="text-2xl font-bold text-slate-800 mb-2"></h2>
            <p id="alert-message" class="text-slate-600 mb-6"></p>
            <button onclick="closeAlert()" class="bg-indigo-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">å¥½çš„ï¼Œæˆ‘ä¼šæ³¨æ„</button>
        </div>
    </div>


    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingSpinner = document.getElementById('loading-spinner');

        const statusText = document.getElementById('status-text');
        const statusCard = document.getElementById('status-card');
        const suggestionText = document.getElementById('suggestion-text');
        const durationText = document.getElementById('duration-text');
        
        const alertModal = document.getElementById('alert-modal');
        const alertIcon = document.getElementById('alert-icon');
        const alertTitle = document.getElementById('alert-title');
        const alertMessage = document.getElementById('alert-message');

        let detector;
        let start_time = Date.now();
        let bad_posture_start_time = null;
        let isAlerting = false;
        
        // --- å§¿åŠ¿åˆ¤å®šé˜ˆå€¼è®¾å®š ---
        // å¯ä»¥æ ¹æ®æ‚¨çš„å®é™…æƒ…å†µå¾®è°ƒè¿™äº›å€¼
        const TILT_THRESHOLD = 15; // è„–å­æˆ–è‚©è†€å€¾æ–œè§’åº¦é˜ˆå€¼ (åº¦)
        const HEAD_DOWN_RATIO_THRESHOLD = 0.75; // ä½å¤´åˆ¤æ–­é˜ˆå€¼ï¼ˆçœ¼ç›åˆ°è‚©è†€çš„å‚ç›´è·ç¦» / è‚©è†€å®½åº¦ï¼‰
        const HUNCHBACK_RATIO_THRESHOLD = 0.2; // å«èƒ¸/å¤´å‰ä¼¸åˆ¤æ–­é˜ˆå€¼ (è€³æœµåˆ°è‚©è†€çš„æ°´å¹³åç§» / è‚©è†€å®½åº¦)
        const BAD_POSTURE_DURATION_THRESHOLD = 3000; // è§¦å‘æé†’æ‰€éœ€çš„ä¸è‰¯å§¿åŠ¿æŒç»­æ—¶é—´ (æ¯«ç§’)


        // ä¸»å‡½æ•°
        async function main() {
            // 1. è®¾ç½® TensorFlow.js åç«¯
            await tf.setBackend('webgl');
            
            // 2. åŠ è½½å§¿åŠ¿æ£€æµ‹æ¨¡å‹
            const model = poseDetection.SupportedModels.MoveNet;
            detector = await poseDetection.createDetector(model, {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
            });

            // 3. å¯åŠ¨æ‘„åƒå¤´
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480 },
                    audio: false
                });
                videoElement.srcObject = stream;
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                canvasElement.width = videoElement.width;
                canvasElement.height = videoElement.height;
                loadingSpinner.style.display = 'none';

                // 4. å¼€å§‹æ£€æµ‹å¾ªç¯
                detectPose();
            } catch (error) {
                console.error("æ— æ³•è®¿é—®æ‘„åƒå¤´: ", error);
                loadingSpinner.innerHTML = '<p class="text-red-500 text-lg">æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ååˆ·æ–°é¡µé¢ã€‚</p>';
            }
        }
        
        // å§¿åŠ¿æ£€æµ‹å¾ªç¯
        async function detectPose() {
            if (detector && videoElement.readyState === 4) {
                 // ä¼°ç®—å§¿åŠ¿
                const poses = await detector.estimatePoses(videoElement, {
                    flipHorizontal: false // å› ä¸ºæˆ‘ä»¬å·²ç»ç”¨CSSç¿»è½¬äº†è§†é¢‘
                });

                // æ¸…ç©ºç”»å¸ƒå¹¶ç»˜åˆ¶è§†é¢‘å¸§
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.save();
                // åŒæ ·ç¿»è½¬ç”»å¸ƒä»¥åŒ¹é…è§†é¢‘
                canvasCtx.scale(-1, 1);
                canvasCtx.translate(-canvasElement.width, 0);
                canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
                canvasCtx.restore();

                if (poses.length > 0) {
                    const keypoints = poses[0].keypoints;
                    // åˆ†æå§¿åŠ¿
                    analyzePosture(keypoints);
                    // åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶éª¨æ¶
                    drawSkeleton(keypoints);
                } else {
                     // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°äººï¼Œé‡ç½®çŠ¶æ€
                     updateStatus('Normal');
                }
            }
            // æŒç»­è°ƒç”¨
            requestAnimationFrame(detectPose);
        }

        // åˆ†æå§¿åŠ¿é€»è¾‘
        function analyzePosture(keypoints) {
            const keypointsMap = {};
            keypoints.forEach(point => {
                if(point.score > 0.5) { // åªä½¿ç”¨ç½®ä¿¡åº¦é«˜çš„å…³é”®ç‚¹
                   keypointsMap[point.name] = point;
                }
            });
            
            // ç¡®ä¿å…³é”®ç‚¹éƒ½å­˜åœ¨
            if (!keypointsMap.left_shoulder || !keypointsMap.right_shoulder || !keypointsMap.left_ear || !keypointsMap.right_ear || !keypointsMap.nose || !keypointsMap.left_eye || !keypointsMap.right_eye) {
                updateStatus('Normal', 'è¯·ç¡®ä¿ä¸ŠåŠèº«åœ¨æ‘„åƒå¤´å†…');
                return;
            }

            const leftShoulder = keypointsMap.left_shoulder;
            const rightShoulder = keypointsMap.right_shoulder;
            const leftEar = keypointsMap.left_ear;
            const rightEar = keypointsMap.right_ear;

            // --- 1. åˆ¤æ–­æ­ªè„–å­ ---
            const shoulderAngle = Math.atan2(rightShoulder.y - leftShoulder.y, rightShoulder.x - leftShoulder.x) * 180 / Math.PI;
            if (Math.abs(shoulderAngle) > TILT_THRESHOLD) {
                updateStatus('Tilted', 'è¯·ä¸è¦æ­ªç€å¤´æˆ–è€¸è‚©ï¼Œä¿æŒåŒè‚©å¹³è¡¡ã€‚');
                return;
            }
            
            const shoulderWidth = Math.hypot(rightShoulder.x - leftShoulder.x, rightShoulder.y - leftShoulder.y);
            const shoulderCenter = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };
            
            // --- 2. åˆ¤æ–­ä½å¤´ ---
            const eyeCenterY = (keypointsMap.left_eye.y + keypointsMap.right_eye.y) / 2;
            const headDownRatio = (shoulderCenter.y - eyeCenterY) / shoulderWidth;
             if (headDownRatio < HEAD_DOWN_RATIO_THRESHOLD) {
                updateStatus('HeadDown', 'å¤´å¤ªä½äº†ï¼Œè¯·æŠ¬èµ·å¤´ï¼Œè®©è§†çº¿ä¸å±å¹•å¹³è¡Œã€‚');
                return;
            }
            
            // --- 3. åˆ¤æ–­å«èƒ¸/å¤´å‰ä¼¸ ---
            const earAvgX = (leftEar.x + rightEar.x) / 2;
            const hunchbackRatio = (shoulderCenter.x - earAvgX) / shoulderWidth;
            if (Math.abs(hunchbackRatio) > HUNCHBACK_RATIO_THRESHOLD) {
                 updateStatus('Hunchback', 'å«èƒ¸é©¼èƒŒäº†ï¼Œè¯·æŒºç›´è…°èƒŒï¼Œå‘åæ‰“å¼€è‚©è†€ã€‚');
                 return;
            }

            // --- 4. å§¿åŠ¿æ­£å¸¸ ---
            updateStatus('Normal', 'å§¿åŠ¿å¾ˆæ£’ï¼Œè¯·ç»§ç»­ä¿æŒï¼');
        }

        // æ›´æ–°ç•Œé¢çŠ¶æ€
        function updateStatus(status, suggestion = '') {
            let statusLabel = '';
            let cardClass = '';

            switch(status) {
                case 'Normal':
                    statusLabel = 'å§¿åŠ¿æ­£å¸¸';
                    cardClass = 'bg-green-100 text-green-800';
                    resetBadPostureTimer();
                    break;
                case 'Tilted':
                    statusLabel = 'æ­ªè„–/è€¸è‚©';
                    cardClass = 'bg-yellow-100 text-yellow-800';
                    trackBadPosture();
                    break;
                case 'HeadDown':
                    statusLabel = 'ä½å¤´';
                    cardClass = 'bg-red-100 text-red-800';
                    trackBadPosture();
                    break;
                case 'Hunchback':
                    statusLabel = 'å«èƒ¸/é©¼èƒŒ';
                    cardClass = 'bg-orange-100 text-orange-800';
                    trackBadPosture();
                    break;
            }
            
            statusText.textContent = statusLabel;
            suggestionText.textContent = suggestion;
            if (statusCard.className !== cardClass) {
                 statusCard.className = `p-4 rounded-lg text-center transition-all duration-300 ${cardClass}`;
            }
        }
        
        // è¿½è¸ªä¸è‰¯å§¿åŠ¿è®¡æ—¶
        function trackBadPosture() {
            if (bad_posture_start_time === null) {
                bad_posture_start_time = Date.now();
            } else {
                const duration = Date.now() - bad_posture_start_time;
                durationText.textContent = `${(duration / 1000).toFixed(2)} ç§’`;
                if (duration > BAD_POSTURE_DURATION_THRESHOLD && !isAlerting) {
                   showAlert();
                }
            }
        }
        
        // é‡ç½®ä¸è‰¯å§¿åŠ¿è®¡æ—¶å™¨
        function resetBadPostureTimer() {
            if (bad_posture_start_time !== null) {
                bad_posture_start_time = null;
                 durationText.textContent = `0.00 ç§’`;
            }
        }

        // æ˜¾ç¤ºå¼¹çª—æé†’
        function showAlert() {
            isAlerting = true;
            const status = statusText.textContent;
            const suggestion = suggestionText.textContent;

            alertTitle.textContent = `è¯·æ³¨æ„ï¼Œæ‚¨å·²${status}ï¼`;
            alertMessage.textContent = suggestion;
            
            if (status.includes('ä½å¤´')) {
                alertIcon.textContent = 'ğŸ˜©';
            } else if (status.includes('å«èƒ¸')) {
                alertIcon.textContent = 'ğŸ§˜';
            } else if (status.includes('æ­ªè„–')) {
                alertIcon.textContent = 'ğŸ¤·';
            }

            alertModal.classList.remove('opacity-0', 'pointer-events-none');
            alertModal.querySelector('div').classList.remove('scale-95');
        }
        
        // å…³é—­å¼¹çª—æé†’
        function closeAlert() {
            isAlerting = false;
            bad_posture_start_time = null; // é‡ç½®è®¡æ—¶å™¨ï¼Œç»™ç”¨æˆ·æ”¹æ­£æ—¶é—´
            alertModal.classList.add('opacity-0', 'pointer-events-none');
            alertModal.querySelector('div').classList.add('scale-95');
        }

        // åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶éª¨æ¶
        function drawSkeleton(keypoints) {
            const adjacentPairs = [
                // ä¸ŠåŠèº«
                ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_elbow'],
                ['right_shoulder', 'right_elbow'], ['left_elbow', 'left_wrist'],
                ['right_elbow', 'right_wrist'], ['left_shoulder', 'left_hip'],
                ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
                // å¤´éƒ¨
                ['left_ear', 'right_ear'], ['nose', 'left_eye'], ['nose', 'right_eye'],
                ['left_eye', 'left_ear'], ['right_eye', 'right_ear']
            ];

            const keypointsMap = {};
            keypoints.forEach(point => {
                keypointsMap[point.name] = point;
            });

            // ç»˜åˆ¶è¿æ¥çº¿
            adjacentPairs.forEach(([p1, p2]) => {
                if (keypointsMap[p1] && keypointsMap[p2] && keypointsMap[p1].score > 0.5 && keypointsMap[p2].score > 0.5) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(keypointsMap[p1].x, keypointsMap[p1].y);
                    canvasCtx.lineTo(keypointsMap[p2].x, keypointsMap[p2].y);
                    canvasCtx.lineWidth = 3;
                    canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                    canvasCtx.stroke();
                }
            });

            // ç»˜åˆ¶å…³é”®ç‚¹
            keypoints.forEach(point => {
                if (point.score > 0.5) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = 'rgba(74, 222, 128, 0.9)'; // äº®ç»¿è‰²
                    canvasCtx.fill();
                }
            });
        }
        
        // å¯åŠ¨åº”ç”¨
        main();

    </script>

</body>
</html>
